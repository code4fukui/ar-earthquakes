<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><link rel="icon" href="data:">
<title>AR Earthquakes</title>
</head>
<body>

<header>
  <h1>AR Earthquakes</h1>
  Earth: <a href=https://github.com/martynafford/natural-earth-geojson/blob/master/110m/physical/ne_110m_coastline.json>ne_110m_coastline.json</a> ← <a href=https://github.com/martynafford/natural-earth-geojson/tree/master>Natural Earth data in GeoJSON</a><br>
  Earthquakes: <a href=hypocenters.csv>hypocenters.csv</a> ← <a href=https://github.com/nagix/japan-eq-locator>nagix/japan-eq-locator</a> ← <a href=https://www.data.jma.go.jp/eqev/data/bulletin/hypo.html>気象庁｜気象庁の地震カタログ</a><br>
  LIB: <a href="https://github.com/code4fukui/egxr.js/">egxr.js</a><br>
  APP: <a href="https://github.com/code4fukui/ar-earthquakes/">src on GitHub</a><br>
</header>

<script type="importmap">
{
  "imports": {
    "three": "https://code4fukui.github.io/three.js/build/three.module.js",
    "three/addons/": "https://code4fukui.github.io/three.js/examples/jsm/"
  }
}
</script>

<script type="module">
import { THREE, scene, camera, renderer } from "https://code4fukui.github.io/egxr.js/egxr.js";
import { OrbitControls } from 'https://code4fukui.github.io/three.js_examples/jsm/controls/OrbitControls.js';
import { CSV } from "https://js.sabae.cc/CSV.js";
import { deg2rad } from "./deg2rad.js";
import { lla2xyz } from "./lla2xyz.js";

const r = .5;

const cx = 0;
const cz = -r - .5;
//const cy = r / 2;
const cy = 0;

camera.position.y = 0; // 1.5;


const createPointsEQ = async () => {
  const data = await CSV.fetchJSON("./hypocenters.csv");
  const vertices = [];
  for (const dd of data) {
    const p = lla2xyz(dd.lat, dd.lng, dd.alt, r);
    vertices.push(p.x, p.y, p.z);
  }
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute("position", new THREE.Float32BufferAttribute(vertices, 3));
  const material = new THREE.PointsMaterial({ size: 0.005, color: 0xff0000 });
  return new THREE.Points(geometry, material);
};

const createSphere = (r) => {
  const geo = new THREE.IcosahedronGeometry(r, 5);
  //const geo = new THREE.SphereGeometry(r, 18, 9);
  //const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
  const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true });
  const mesh = new THREE.Mesh(geo, mat);
  return mesh;
};

const createCoastLines = async () => {
  const geojson = await (await fetch("./ne_110m_coastline.json")).json();
  const grp = new THREE.Group();
  for (const f of geojson.features) {
    if (f.geometry.type != "LineString") continue;
    const points = f.geometry.coordinates.map(i => {
      const p = lla2xyz(Math.PI - i[0], i[1], 0, r);
      return new THREE.Vector3(p.x, p.y, p.z);
    });
    const geo = new THREE.BufferGeometry().setFromPoints(points);
    grp.add(new THREE.Line(geo, new THREE.LineBasicMaterial({ color: "green" })));
  }
  return grp;
};

const o = new THREE.Group();
o.add(await createSphere(r * 1.015));
o.add(await createCoastLines());
o.add(await createPointsEQ());

o.rotation.x = deg2rad(90);
o.rotation.z = deg2rad(-100);
o.position.set(cx, cy, cz);
scene.add(o);

// control
const controls = new OrbitControls(camera, renderer.domElement);
console.log(controls);

const clock = new THREE.Clock();
renderer.setAnimationLoop(() => {
  controls.update();
  o.rotation.z -= .0005;
  renderer.render(scene, camera);
});

</script>
</body>
</html>
